/find_min_dist_node {
  /param_consider exch def
  /param_distances exch def
  
  % Initialize variables
  /min_dist_index -1 def
  /min_dist infinity def

  % Loop through the list of nodes
  /i 0 def
  param_distances
  {
    % Get the current node and its distance
    /current_distance exch def

    % Update the minimum distance and node if necessary
    current_distance min_dist lt
    param_consider i get
    and    
    {
      /min_dist current_distance def
      /min_dist_index i def
    } if

    i 1 add
    /i exch def
  } forall

  % Return the index of the minimum distance node
  min_dist_index
} def

/dijkstra {
  /param_start_node exch def
  /param_edges exch def

  param_edges length array /distances exch def
  param_edges length array /prev exch def
  param_edges length array /visited exch def
  
  0 1 distances length 1 sub {
    /distances_iterator exch def
    distances distances_iterator infinity put
    prev distances_iterator 0 put
    visited distances_iterator true put
  } for
  distances param_start_node 0 put


  % Loop until all nodes are visited
  param_edges {
    % Find the minimum distance node that has not been visited
    
    distances visited find_min_dist_node
    /node exch def

    % Stop if there is no unvisited node with a minimum distance
    node -1 eq {
      exit
    } if

    % Add the node to the visited list
    visited node false put

    % Update the distances of the neighboring nodes
     0 1 param_edges length 1 sub {
      /neighbor exch def

      % Skip if the neighbor has already been visited
      visited neighbor get {
        % Calculate the new distance of the neighbor
        distances node get
        param_edges node get neighbor get
        add
        /new_dist exch def

        % Update the distance of the neighbor if necessary
        new_dist 
        distances neighbor get
        lt {
          distances neighbor new_dist put
          prev neighbor node put
        } if
      } if
    } for
  } forall

  distances
} def

/calculate_coordinates {
    /node exch def
    /x angle node mul cos radius mul def
    /y angle node mul sin radius mul def
    x y
} def


/draw_edge {
  newpath
  calculate_coordinates moveto
  calculate_coordinates lineto
  0 0 0 setrgbcolor
  stroke
  closepath
} def

/draw_graph {
  /num_of_nodes edges length def
  /radius 100 def
  /angle 360 num_of_nodes div def
  num_of_nodes =
  radius =
  angle =
  
  << /PageSize [400 400] >> setpagedevice
  1 setlinewidth
  200 200 translate

  0 1 num_of_nodes 1 sub {
    /i exch def

    0 1 num_of_nodes 1 sub {
      /j exch def
      edges i get j get infinity ne {
        i j draw_edge
      } if
    } for 

  } for

  0 1 num_of_nodes 1 sub {
    /i exch def
    
    newpath
    i calculate_coordinates 10 0 360 arc
    0 0 0 setrgbcolor
    stroke
    i calculate_coordinates 10 0 360 arc
    1 1 1 setrgbcolor
    fill

    /Helvetica findfont
    12 scalefont setfont
    i calculate_coordinates exch 3 sub exch 4 sub moveto
    0 0 0 setrgbcolor
    i ( ) cvs show
    i =
  } for
} def

/infinity 99999 def

/edges [  
  [ 0 infinity 10  infinity infinity infinity infinity ]
  [ infinity 0  infinity 5   infinity 15  20 ]
  [ infinity 5  0   20  infinity infinity infinity ]
  [ infinity infinity infinity 0   15  infinity infinity ]
  [ infinity infinity infinity infinity 0   infinity 10 ]
  [ infinity infinity infinity infinity 20  0   5  ]
  [ infinity infinity infinity infinity infinity infinity 0 5  ]
] def


% Define an array with some values
% edges 0 dijkstra {=} forall
draw_graph
quit

% 0. Committen
% 1. Nodes dynamisch am Kreis anordnen
% 2. Nodes brauchen Labels
% 3. Nodes m√ºssen entsprechend der Edges verbunden werden
% 4. Pfad einzeichnen